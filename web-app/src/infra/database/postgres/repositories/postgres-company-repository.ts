import { Company } from "@/src/application/entities/Company/Company"
import { CompanyErrors } from "@/src/application/errors/company"
import { CompanyRepository } from "@/src/application/repositories/company-repository"
import { PostgresService } from "@/src/infra/services/postgres"
import { AutoGenerateds } from "@/src/shared/entities/AutoGenerateds"
import { UUID } from "@/src/shared/entities/UUID"
import { injectable } from "@/src/shared/utils/dependency-injection"
import f from "pg-format"
import { CompanyMapper } from "../mappers/company-mapper"

@injectable("Postgres")
export class PostgresCompanyRepository implements CompanyRepository {
  public async add({
    name,
    ownerUserId,
    authorizedUsersIds,
  }: Omit<Company, keyof AutoGenerateds>): Promise<Company> {
    using client = await PostgresService.connect()

    try {
      await client.query("BEGIN")

      const { rows: rowsCreateCompany } = await client.query<{
        id: number
        name: string
        owner_user_id: string
        created_at: Date
        updated_at: Date
      }>(
        `--sql
        INSERT INTO public.companies(name, owner_user_id)
        VALUES ($1, $2)
        RETURNING id, name, owner_user_id, created_at, updated_at
        `,
        [name, ownerUserId.toString()],
      )

      if (rowsCreateCompany.length === 0) {
        throw new CompanyErrors.CompanyNotCreatedInDatabaseError()
      }

      await this.addAuthorizedUsers(
        authorizedUsersIds.map((userId) => ({
          userId,
          authorId: ownerUserId,
          companyId: rowsCreateCompany[0].id,
        })),
        client.query.bind(client),
      )

      await client.query("COMMIT")

      return CompanyMapper.toDomain({
        id: rowsCreateCompany[0].id,
        name: rowsCreateCompany[0].name,
        authorized_users_ids: authorizedUsersIds.map((id) => id.toString()),
        owner_user_id: rowsCreateCompany[0].owner_user_id,
        created_at: rowsCreateCompany[0].created_at,
        updated_at: rowsCreateCompany[0].updated_at,
      })
    } catch (error) {
      await client.query("ROLLBACK")
      throw error
    }
  }

  public async addAuthorizedUsers(
    authorizes: CompanyRepository.AddAuthorizedUserPayload[],
    query = PostgresService.query,
  ): Promise<void> {
    const { rowCount } = await query<{ id: number }>(
      f(
        `--sql
      INSERT INTO public.company_authorized_users(user_id, company_id, author_id)
      VALUES %L
      RETURNING id
    `,
        authorizes.map(({ userId, authorId, companyId }) => [
          userId.toString(),
          companyId,
          authorId.toString(),
        ]),
      ),
    )

    if (rowCount === 0) {
      throw new CompanyErrors.UserNotAddedToCompanyError()
    }
  }

  public async get(id: number): Promise<Company> {
    const { rows: rowsCompany } = await PostgresService.query<{
      id: number
      name: string
      owner_user_id: string
      updated_at: Date
      created_at: Date
    }>(
      `--sql
        SELECT 
          companies.id,
          companies.name,
          companies.owner_user_id,
          companies.updated_at,
          companies.created_at
        FROM public.companies companies
        WHERE companies.id = $1
      `,
      [id],
    )

    if (rowsCompany.length === 0) {
      throw new CompanyErrors.CompanyNotFoundError()
    }

    const { rows: rowsAuthorizedUsers } = await PostgresService.query<{
      user_id: string
    }>(
      `--sql
          SELECT users.user_id
          FROM public.company_authorized_users users
          WHERE users.company_id = $1
          `,
      [id],
    )

    return CompanyMapper.toDomain({
      id: rowsCompany[0].id,
      name: rowsCompany[0].name,
      authorized_users_ids: rowsAuthorizedUsers.map((user) => user.user_id),
      owner_user_id: rowsCompany[0].owner_user_id,
      created_at: rowsCompany[0].created_at,
      updated_at: rowsCompany[0].updated_at,
    })
  }

  public async getByAuthorizedUserId(userId: UUID): Promise<Company[]> {
    const { rows: rowsCompany } = await PostgresService.query<{
      id: number
      name: string
      owner_user_id: string
      updated_at: Date
      created_at: Date
    }>(
      `--sql
        SELECT 
          companies.id,
          companies.name,
          companies.owner_user_id,
          companies.updated_at,
          companies.created_at
        FROM public.companies companies
          INNER JOIN public.company_authorized_users auth_users
            ON auth_users.company_id = companies.id AND auth_users.user_id = $1
        ORDER BY companies.created_at DESC
      `,
      [userId.toString()],
    )

    if (rowsCompany.length === 0) {
      throw new CompanyErrors.CompanyNotFoundError()
    }

    const queryGetRowAuthorizedUsers = f(
      `--sql
      SELECT users.user_id, users.company_id
      FROM public.company_authorized_users users
      WHERE users.company_id IN (%L)
    `,
      rowsCompany.map(({ id }) => id),
    )

    const { rows: rowsAuthorizedUsers } = await PostgresService.query<{
      user_id: string
      company_id: number
    }>(queryGetRowAuthorizedUsers)

    const companies = rowsCompany.map((company) => ({
      ...company,
      authorized_users_ids: rowsAuthorizedUsers
        .filter((authUser) => authUser.company_id === company.id)
        .map((user) => user.user_id),
    }))

    return companies.map(CompanyMapper.toDomain)
  }

  public async update(
    companyId: number,
    { name, ownerUserId }: CompanyRepository.UpdatePayload,
  ): Promise<Company> {
    const { rows } = await PostgresService.query<{
      id: number
      name: string
      owner_user_id: string
      created_at: Date
      updated_at: Date
    }>(
      `--sql
      UPDATE public.companies SET
        updated_at = NOW(),
        name = $1,
        owner_user_id = $2
      WHERE id = $3
      RETURNING
        id,
        name,
        owner_user_id,
        created_at,
        updated_at
    `,
      [name, ownerUserId.toString(), companyId],
    )

    if (rows.length === 0) {
      throw new CompanyErrors.CompanyNotUpdatedInDatabaseError()
    }

    const { rows: rowsAuthorizedUsers } = await PostgresService.query<{
      user_id: string
    }>(
      `--sql
          SELECT users.user_id
          FROM public.company_authorized_users users
          WHERE users.company_id = $1
          `,
      [companyId],
    )

    return CompanyMapper.toDomain({
      id: rows[0].id,
      name: rows[0].name,
      authorized_users_ids: rowsAuthorizedUsers.map((user) => user.user_id),
      owner_user_id: rows[0].owner_user_id,
      created_at: rows[0].created_at,
      updated_at: rows[0].updated_at,
    })
  }

  public async isUserAuthorized(companyId: number, userId: UUID): Promise<boolean> {
    const { rowCount } = await PostgresService.query(
      `--sql
        SELECT 1
        FROM public.company_authorized_users
        WHERE company_id = $1 AND user_id = $2
      `,
      [companyId, userId.toString()],
    )

    return (rowCount ?? 0) > 0
  }

  public async save(company: Company): Promise<void> {}
}
